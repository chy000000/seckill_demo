# 商品秒杀项目

## 概述

本项目是一套电商系统，基于SpringBoot+MyBatisplus+redis+rabbitmq实现，主要解决秒杀应用场景下的高并发问题。秒杀其实主要解决两个问题，一个是并发读，一个是并发写。并发读的核心优化 理念是尽量减少用户到服务端来“读”数据，或者让他们读更少的数据；并发写的处理原则也一样，它要求我们在数据库层面独立出来一个库，做特殊的处理。

所以从技术角度上看“稳、准、快”，就对应了我们架构上的高可用、一致性和高性能的要求 

* **高性能。** 秒杀涉及大量的并发读和并发写，因此支持高并发访问这点非常关键。对应的方案比如 动静分离方案、热点的发现与隔离、请求的削峰与分层过滤、服务端的极致优化 。

* **一致性。** 秒杀中商品减库存的实现方式同样关键。可想而知，有限数量的商品在同一时刻被很多 倍的请求同时来减库存，减库存又分为“拍下减库存”“付款减库存”以及预扣等几种，在大并发更新 的过程中都要保证数据的准确性，其难度可想而知 。

* **高可用。** 现实中总难免出现一些我们考虑不到的情况，所以要保证系统的高可用和正确性，我们 还要设计一个 PlanB 来兜底，以便在最坏情况发生时仍然能够从容应对。

## 项目使用框架介绍

### SpringBoot

> SpringBoot可以让你快速构建基于Spring的Web应用程序，内置多种Web容器(如Tomcat)，通过启动入口程序的main函数即可运行。

### Mybatis-Plus

> [MyBatis-Plus (opens new window)](https://github.com/baomidou/mybatis-plus)（简称 MP）是一个 [MyBatis (opens new window)](https://www.mybatis.org/mybatis-3/)的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。MyBatis 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。

## 项目搭建

**使用IDEA初始化SpringBoot项目**

![image-20220430111743684](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430111743684.png)

### 项目目录架构

![image-20220430111912599](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430111912599.png)

### Mybayis-Plus逆向工程

> 官方文档教程：https://baomidou.com/pages/779a6e/



### SpringBoot整合redist

### SpringBoot整合rabbitmq

## API接口

### 接口说明

* 接口基准地址：`http://localhost:8080`
* 数据返回格式统一使用 JSON

### 支持请求方法

- GET（SELECT）：从服务器取出资源（一项或多项）。
- POST（CREATE）：在服务器新建一个资源。
- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。
- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。
- DELETE（DELETE）：从服务器删除资源。
- HEAD：获取资源的元数据。
- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。

### 通用返回状态说明

| *状态码* | *类别*         | *说明*                   |
| -------- | -------------- | ------------------------ |
| 200      | SUCCESS        | 请求成功                 |
| 500      | 内部错误       | 服务端异常               |
| 500210   | 登录模块5002xx | 用户名或密码不正确       |
| 500211   | 登录模块5002xx | 手机号码格式不正确       |
| 500212   | 登录模块5002xx | 参数校验异常             |
| 500213   | 登录模块5002xx | 手机号码不存在           |
| 500214   | 登录模块5002xx | 密码更新失败             |
| 500215   | 登录模块5002xx | 用户不存在               |
| 500500   | 秒杀模块5005xx | 库存不足                 |
| 500501   | 秒杀模块5005xx | 该商品每人限购一件       |
| 500502   | 秒杀模块5005xx | 请求非法，请重新尝试     |
| 500503   | 秒杀模块5005xx | 验证码错误，请重新输入   |
| 500504   | 秒杀模块5005xx | 访问过于频繁，请稍后再试 |
| 500300   | 订单模块5003xx | 订单信息不存在           |

### 请求

由于项目未实现前后端分离，部分Controller直接返回跳转页面。

#### 用户登录

- 请求路径：/login/toLogin

- 请求方法：post

- 请求参数

  | 参数名   | 参数说明 | 备注     |
  | -------- | -------- | -------- |
  | mobile   | 手机号   | 不能为空 |
  | password | 密码     | 不能为空 |

- 跳转页面：/goods/toList

#### 商品展示列表

- 请求路径：/list/toList

- 请求方法：get

- 请求参数

  无

- 响应数据：商品展示列表

#### 商品详情

- 请求路径：/list/toDetail

- 请求方法：post

- 请求参数

  | 参数名  | 参数说明 | 备注     |
  | ------- | -------- | -------- |
  | goodsId | 商品ID   | 不能为空 |

- 响应数据

  ```
  {
   "code":500501,
   "message":"该商品每人限购一件",
   "obj":{
    "user": {
     
    },
    "goodsVo": {
    
    },
    secKillStatus: 1,
    remainSeconds: 0
   }
  }
  ```

#### 获取秒杀地址

- 请求路径：/seckill/path

- 请求方法：get

- 请求参数

  | 参数名  | 参数说明 | 备注     |
  | ------- | -------- | -------- |
  | goodsId | 商品ID   | 不能为空 |
  | captcha | 验证码   | 不能为空 |

- 响应数据

  ```
  {
   "code":200,
   "message":"SUCCESS",
   "obj":"be5a37900feadfcd55d15b35072ac89b"
  }
  ```

#### 秒杀

- 请求路径：/seckill/{path}/doSeckill

- 请求方法：post

- 请求参数

  | 参数名  | 参数说明 | 备注     |
  | ------- | -------- | -------- |
  | goodsId | 商品ID   | 不能为空 |

- 响应数据

  ```
  {
   "code":200,
   "message":"SUCCESS",
   "obj":0
  }
  ```

#### 秒杀结果

- 请求路径：/seckill/getResults

- 请求方法：get

- 请求参数

  | 参数名  | 参数说明 | 备注     |
  | ------- | -------- | -------- |
  | goodsId | 商品ID   | 不能为空 |

- 响应数据

  ```
  {
   "code":200,
   "message":"SUCCESS",
   "obj": 2324
  }
  ```

#### 订单详情

- 请求路径：/order/detail

- 请求方法：get

- 请求参数

  | 参数名  | 参数说明 | 备注     |
  | ------- | -------- | -------- |
  | orderId | 订单ID   | 不能为空 |

- 响应数据

  ```
  {
   "code":200,
   "message":"SUCCESS",
   "obj":{
    "order":{
     "id":2324,
     "userId":18899059686,
     "goodsId":1,
     "deliveryAddrId":0,
     "goodsName":"IPHONE12",
     "goodsCount":1,
     "goodsPrice":629.00,
     "orderChannel":1,
     "status":0,"createDate":"2022-04-30T08:43:42.000+00:00",
     "payDate":null
    },
    "goodsVo":{
     "id":1,"goodsName":"IPHONE12",
     "goodsTitle":"IPHONE 12 64GB",
     "goodsImg":"/img/iphone12.png",
     "goodsDetail":"IPHONE12 64GB",
     "goodsPrice":6299.00,
     "goodsStock":100,
     "seckillPrice":629.00,
     "stockCount":9,
     "startDate":"2022-04-29T13:46:00.000+00:00",
     "endDate":"2022-04-30T13:48:00.000+00:00"
    }
   }
  }
  ```

  

## 工具学习

### Mybatis-plus

### redis

### rabbitmq

### JMeter

## 总结

1. 用户登录
   * 设计数据库
   * 明文密码二次MD5加密
   * 参数校验+全局异常处理
2. 共享Session
   * SpringSession
   * Redis
3. 功能列表
   * 商品列表
   * 商品详情
   * 秒杀
   * 订单详情
4. 系统压测
   * JMeter使用
5. 页面优化
   * 页面缓存+URL缓存+对象缓存
   * 页面静态化，前后端分离
   * 静态资源优化
   * CDN优化
6. 接口优化
   * Redis预减库存
   * 内存标记减少Redis访问
   * RabbitMQ异步下单
7. 安全优化
   * 秒杀地址隐藏
   * 算术验证码
   * 接口限流防刷

## 秒杀系统设计

![image-20220430165630556](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430165630556.png)

### 页面静态化

活动页面是用户流量的第一入口，所以是并发量最大的地方。

如果这些流量都能直接访问服务端，恐怕服务端会因为承受不住这么大的压力，而直接挂掉。 

![image-20220430165710209](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430165710209.png)

活动页面绝大多数内容是固定的，比如：商品名称、商品描述、图片等。为了减少不必要的服务端请求，通常情况下，会对活动页面做静态化处理。用户浏览商品等常规操作，并不会请求到服务端。只有到了秒杀时间点，并且用户主动点了秒杀按钮才允许访问服务端。 

![image-20220430165725063](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430165725063.png)

这样能过滤大部分无效请求。

但只做页面静态化还不够，因为用户分布在全国各地，有些人在北京，有些人在成都，有些人在深圳，地域相差很远，网速各不相同。

如何才能让用户最快访问到活动页面呢？

这就需要使用CDN，它的全称是Content Delivery Network，即内容分发网络。

![image-20220430165745158](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430165745158.png)

### 秒杀按钮 ——隐藏秒杀地址

### 读多写少——redis预见库存

在秒杀的过程中，系统一般会先查一下库存是否足够，如果足够才允许下单，写数据库。如果不够，则直接返回该商品已经抢完。

由于大量用户抢少量商品，只有极少部分用户能够抢成功，所以绝大部分用户在秒杀时，库存其实是不足的，系统会直接返回该商品已经抢完。

这是非常典型的：读多写少 的场景。 

![image-20220430165923450](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430165923450.png)

如果有数十万的请求过来，同时通过数据库查缓存是否足够，此时数据库可能会挂掉。因为数据库的连接资源非常有限，比如：mysql，无法同时支持这么多的连接。

而应该改用缓存，比如：redis。

即便用了redis，也需要部署多个节点。 

![image-20220430165937745](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430165937745.png)

### 缓存问题 

通常情况下，我们需要在redis中保存商品信息，里面包含：商品id、商品名称、规格属性、库存等信息，同时数据库中也要有相关信息，毕竟缓存并不完全可靠。

用户在点击秒杀按钮，请求秒杀接口的过程中，需要传入的商品id参数，然后服务端需要校验该商品是否合法。

大致流程如下图所示： 

![image-20220430170035777](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170035777.png)

根据商品id，先从缓存中查询商品，如果商品存在，则参与秒杀。如果不存在，则需要从数据库中查询商品，如果存在，则将商品信息放入缓存，然后参与秒杀。如果商品不存在，则直接提示失败。

这个过程表面上看起来是OK的，但是如果深入分析一下会发现一些问题。 

* 缓存击穿
* 缓存穿透

### 库存问题 

对于库存问题看似简单，实则里面还是有些东西。

真正的秒杀商品的场景，不是说扣完库存，就完事了，如果用户在一段时间内，还没完成支付，扣减的库存是要加回去的。

所以，在这里引出了一个预扣库存的概念，预扣库存的主要流程如下：

![image-20220430170147150](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170147150.png)

扣减库存中除了上面说到的预扣库存和回退库存之外，还需要特别注意的是库存不足和库存超卖问题。

* 数据库扣减库存

  注意使用sql原子性，将语句合并为一句不会出现超卖

* redis扣减库存

  使用incrby或decrby等原子操作，或使用lua脚本保证原子性

### 分布式锁

使用redis实现

```java
public void testLock03() {
    ValueOperations valueOperations = redisTemplate.opsForValue();
    String value = UUID.randomUUID().toString();
    Boolean isLock = valueOperations.setIfAbsent("k1", value, 120, TimeUnit.SECONDS);
    if (isLock) {
        valueOperations.set("name", "chy");
        String name = (String) valueOperations.get("name");
        System.out.println("name = " + name);
        System.out.println(valueOperations.get("k1"));
        Boolean result = (Boolean) redisTemplate.execute(script, Collections.singletonList("k1"), value);
        System.out.println(result);
    } else {
    	System.out.println("有线程在使用！");
    }
}
```

### mq异步处理 

我们都知道在真实的秒杀场景中，有三个核心流程：

![image-20220430170831516](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170831516.png)

而这三个核心流程中，真正并发量大的是秒杀功能，下单和支付功能实际并发量很小。所以，我们在设计秒杀系统时，有必要把下单和支付功能从秒杀的主流程中拆分出来，特别是下单功能要做成mq异步处理的。而支付功能，比如支付宝支付，是业务场景本身保证的异步。

于是，秒杀后下单的流程变成如下：

![image-20220430170846782](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170846782.png)

如果使用mq，需要关注以下几个问题： 

* 消息丢失问题 

  秒杀成功了，往mq发送下单消息的时候，有可能会失败。原因有很多，比如：网络问题、broker挂了、mq服务端磁盘问题等。这些情况，都可能会造成消息丢失。

  那么，如何防止消息丢失呢？

  答：加一张消息发送表。 

  ![image-20220430170918872](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170918872.png)

  在生产者发送mq消息之前，先把该条消息写入消息发送表，初始状态是待处理，然后再发送mq消息。消费者消费消息时，处理完业务逻辑之后，再回调生产者的一个接口，修改消息状态为已处理。

  如果生产者把消息写入消息发送表之后，再发送mq消息到mq服务端的过程中失败了，造成了消息丢失。

  这时候，要如何处理呢？

  答：使用job，增加重试机制。

  ![image-20220430170931546](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170931546.png)

* 重复消费问题

  本来消费者消费消息时，在ack应答的时候，如果网络超时，本身就可能会消费重复的消息。但由于消息发送者增加了重试机制，会导致消费者重复消息的概率增大。

  那么，如何解决重复消息问题呢？

  答：加一张消息处理表。 

  ![image-20220430170958377](C:\Users\chy\Desktop\DataBase\seckill_demo\img\image-20220430170958377.png)

  消费者读到消息之后，先判断一下消息处理表，是否存在该消息，如果存在，表示是重复消费，则直接返回。如果不存在，则进行下单操作，接着将该消息写入消息处理表中，再返回。

  有个比较关键的点是：下单和写消息处理表，要放在同一个事务中，保证原子操作。 

* 垃圾消息问题 

  这套方案表面上看起来没有问题，但如果出现了消息消费失败的情况。比如：由于某些原因，消息消费者下单一直失败，一直不能回调状态变更接口，这样job会不停的重试发消息。最后，会产生大量的垃圾消息。

  那么，如何解决这个问题呢？

  每次在job重试时，需要先判断一下消息发送表中该消息的发送次数是否达到最大限制，如果达到了，则直接返回。如果没有达到，则将次数加1，然后发送消息。

  这样如果出现异常，只会产生少量的垃圾消息，不会影响到正常的业务。

* 延迟消费问题 

  通常情况下，如果用户秒杀成功了，下单之后，在15分钟之内还未完成支付的话，该订单会被自动取消，回退库存。

  那么，在15分钟内未完成支付，订单被自动取消的功能，要如何实现呢？

  我们首先想到的可能是job，因为它比较简单。

  但job有个问题，需要每隔一段时间处理一次，实时性不太好。

  还有更好的方案？

  答：使用延迟队列。

  我们都知道rocketmq，自带了延迟队列的功能。

  下单时消息生产者会先生成订单，此时状态为待支付，然后会向延迟队列中发一条消息。达到了延迟时间，消息消费者读取消息之后，会查询该订单的状态是否为待支付。如果是待支付状态，则会更新订单状态为取消状态。如果不是待支付状态，说明该订单已经支付过了，则直接返回。

  还有个关键点，用户完成支付之后，会修改订单状态为已支付。 

###  如何限流？

通过秒杀活动，如果我们运气爆棚，可能会用非常低的价格买到不错的商品（这种概率堪比买福利彩票中大奖）。

但有些高手，并不会像我们一样老老实实，通过秒杀页面点击秒杀按钮，抢购商品。他们可能在自己的服务器上，模拟正常用户登录系统，跳过秒杀页面，直接调用秒杀接口。

如果是我们手动操作，一般情况下，一秒钟只能点击一次秒杀按钮。

但是如果是服务器，一秒钟可以请求成上千接口。

这种差距实在太明显了，如果不做任何限制，绝大部分商品可能是被机器抢到，而非正常的用户，有点不太公平。

所以，我们有必要识别这些非法请求，做一些限制。那么，我们该如何现在这些非法请求呢？

* 基于nginx限流
* 基于redis限流

#### 对同一用户限流 

为了防止某个用户，请求接口次数过于频繁，可以只针对该用户做限制。

限制同一个用户id，比如每分钟只能请求5次接口。 

#### 对同一ip限流

有时候只对某个用户限流是不够的，有些高手可以模拟多个用户请求，这种nginx就没法识别了。

这时需要加同一ip限流功能。

限制同一个ip，比如每分钟只能请求5次接口。

但这种限流方式可能会有误杀的情况，比如同一个公司或网吧的出口ip是相同的，如果里面有多个正常用户同时发起请求，有些用户可能会被限制住。 

#### 对接口限流 

别以为限制了用户和ip就万事大吉，有些高手甚至可以使用代理，每次都请求都换一个ip。

这时可以限制请求的接口总次数。

在高并发场景下，这种限制对于系统的稳定性是非常有必要的。但可能由于有些非法请求次数太多，达到了该接口的请求上限，而影响其他的正常用户访问该接口。看起来有点得不偿失。 

#### 加验证码 

相对于上面三种方式，加验证码的方式可能更精准一些，同样能限制用户的访问频次，但好处是不会存在误杀的情况。

通常情况下，用户在请求之前，需要先输入验证码。用户发起请求之后，服务端会去校验该验证码是否正确。只有正确才允许进行下一步操作，否则直接返回，并且提示验证码错误。

此外，验证码一般是一次性的，同一个验证码只允许使用一次，不允许重复使用。

普通验证码，由于生成的数字或者图案比较简单，可能会被破解。优点是生成速度比较快，缺点是有安全隐患。

还有一个验证码叫做：移动滑块，它生成速度比较慢，但比较安全，是目前各大互联网公司的首选。

